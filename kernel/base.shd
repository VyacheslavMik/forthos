"




















































These flags bits are in the length count byte of the name string
 of an entry in a vocabulary.


































History state         TIB itself

Room for return stack, then TIB state









































































































































































































































































































































































































































































































































































































































































































































































































































Place to back-patch \"cold\"'s CFA



Set up ForthOS environment and start executing words
   Set operand and return stack to our memory

   Initialize direction
   Record eax/ebx, filled in by Multiboot loader

   Jump to our cold start code



















































        Pointer to vocabulary which is receiving definitions
        This cell points to a list of all vocabularies on the system














































































































































































































































code (do)
   Register our support code for the metacompiler
   Make room for our three return stack arguments:
    Iteration point (with ptr to exit point)
    And our current count and termination value





































































































































































































































































































code tuck Insert copy of top below second


code 0< Return true if n is negative






















































































































































































































































Priority of user task

A keystroke seen from (key?) and stored for key?/key

A word is about to be compile, this hook lets a debugging system
 insert some trap code.  We also have a count so this can be suspended
 temporarily when needed (e.g., exec:)

Trap to debugger, for generated code and for aborts

Current working directory, followed by root directory

Reentrant temporary storage for applications

Pointer to stack frame on return stack for local variables



































: ?dup Dup tos if it is not zero



: rot Rot 3rd item to top



: -rot Rot top item to 3rd



: 2drop Discard two items on stack


: 2drop Duplicate top two items









code + Add top two items


: not Bitwise inversion

: dnegate Two's complement negation of double value

code on/off Put boolean value into cell at location


code inc/dec Increment/decrement cell at location


















































































































code 0= Return true if top is 0




code <> Return true if two words are not equal




















































































































































































































































Our boolean values


: >char Filter non-printing characters

: depth Return the depth of the data stack

: pick Copy the nth stack item to tos

: +! Add n to the contents at address a
: c+! Add n to the byte contents at address a














Load/store of double and triple words








: count Return count byte of a string and add 1 to byte address

: do$ Return the address of a compiled string













: catch Execute word at ca and set up an error frame for it
   Save error frame
   Mark error frame, then execute passed routine
   Restore error frame
   No error, no need to reset stack, just return 0

: throw Reset system to current local error frame, update err flag
   Restore return stack
   Restore handler frame
   Save error # on return stack, then restore data stack
   Drop old \"ca\" from \"catch\", get error # back, and return

: @execute Fetch vector and execute if non-zero

: (abort) Do the actual abort
: (abort\") Run time routine of abort\" . Abort with a message.

Hook for metacompiler use













Make #TIBLINE visible to the source






























































































code fill Fill u bytes of character c to area beginning at a


code wfill Fill u-count words (cells) of value u-val beginning at a


: erase Zero u bytes at area beginning at b




























































































: -digit Convert digit to value, abort on bad digit.  (Abort path
 has to restore base, which may have been overriden in \"number\")

: 10*+ Accumulate another numeric position

: +ch Advance char pointer one position



















: number Convert a number string to integer
   Save string pointer (for error display), also save base
   Flag negative number, we'll build as positive and convert at end
   Switch to hex input on $<hex>
   $c puts in \"c\"'s ASCII value
   Otherwise loop across digits, assembling a value





: (key?) Return input character and true, or a false if no input









































































































































code (parse) ( b u c -- b u <delta> )
               dl has delim, ebx has ptr, ecx has count
   Original count & ptr are left on stack; ptr used to generate delta
   If delim is blank, skip leading whitespace
       This is the loop for skipping leading whitespace


Now scan bytes until delim, any non-blank delim will do



This is the same as the loop above, but looking for a single, specific
 delim


Assembled word until end of input; no delim found at end


No word assembled, restore pointers and return delta of 0

Assembled until delim found
















































































Mask of length bits in name field of directory entry
code find Search a vocabulary for a counted string, see notes below
            ecx points to current vocab entry being checked
       Advance to next vocab entry
   ebx points to name, check count against current vocab entry

   Advance ebx, edx points to rest of entry name, count in al
Check next char, leave on mismatch
   Decrement count of chars in strings
   Advance string pointers and loop
Point back to LFA of entry, then iterate loop
Search failed, return search string and 0
Success, entry points at name so back up to CFA and fetch it to get
 actual code address.  NFA and CA are returned on stack.

Notes: ecx holds the current vocab entry being checked.  We leave the
 string being searched on the stack, as we're a little short of registers.
 Since the string compare moves the pointers, we have the entry's string
 in edx for the compare, and the search string in ebx.





                                                                     vandys

: (dot?) Tell if there's a dot embedded in the string.  Returns
 original pointer, and pointer to dot or 0.

: (str>len) Calculate length of base portion of string
: (str>base) Make \"a\" point to just base portion of string
 (the part up to, but not including, the dot)
: (ext>str) Restore \"a\" to the whole string
: (base>str) Switch from base back to whole string
: (str>ext) Make a' point to just extension portion of string
: (unbase) Move from base back to str, avoiding vocab addr on TOS
: ca>nfa Walk from beginning of code back to NFA
: voc>nfa Walk back from body of vocab to its NFA
: (cnt) Return count for vocab entry
: (ent=) Compare two vocab entries, return whether they're the same
 name.









: (vocab?) Find a vocabulary based on its name
   Convert to base and walk vocabulary chain...
   Next vocabulary...  Compare names
      Found, return success
   Loop... return just ( a 0 ) for failure

: dotname? Handle vocab.name format
   Burst to dotted components
   Find vocabulary;               Find name in vocabulary
   Found; restore string and return ca/na
   Not found; restore string and return base of string and false

Vector for local variable names, which take precedence over others
: name? Search all vocabularies for a string
   If locals, search'em first
   Don't search vocab twice if context == 1st vocab in search order
   Loop       Get next vocab to search, advancing pointer
      End of list, not found so try <vocab>.<name> format
      Search this vocab, leave if we find the name





                                                                     shacham
 (#tib>c) and (#tib>dist) store the current key and the distance
from cur to end-of-text when intermediate words require
usage of ( bot eot cur ) on the stack.  '3 roll' and '3 pick'
promise the functionality of moving top-of-stack under
the said triple and back, but the words are not available.



















                                                                     shacham
Line editing bash/emacs style -
: ^a  place cursor at begining of buffer
: ^b  move cursor one char left, if possible
: ^d  remove char under cursor and move command line one char left
: ^e  place cursor at end-of-text, i.e. following right-most non-blank char
: ^f  move cursor one char right, up to end of text
: ^h  remove char left of cursor and move command line one char left
: ^k  delete all text from cursor till end of line
: ^u  delete all text left of cursor

Line editing words get as input the triple
 bot - start of input buffer, i.e. bob
 eot - end of input buffer, i.e. eob
 cur - current location of cursor
thus nowhere is the location of end of actual text entered by user.

Therfore, (cur>eot) calculates the number of chars from cur to
the right-most non-blank char.  The info is used for placing
the cursor at the end of text.  Another example of usage is for
shifting text when deleting/adding a char within the string.
If there are trailing blanks beteween cur and end-of-text, the distance
is considered 0, i.e. the trailing blanks are considered text.

A caveat: Trailing blanks are lost in ^e when the cursor is left of eot.


: tap  In insert mode, when cursor is not at end-of-text, move command line
       one char to right, then put the current key in place.

TODO: Handle override mode.



















\\                                                                    vandys
History counters and buffer are all in 'user tib'.  The variables
start after tib, and the array of history commands follows.
The history command buffer should have a power of 2 entries.

The history command index (hist>put) is a running counter, which warps
around at cell boundary.  (histmask) maps the counter to a buffer index
by masking the relevant least significant bits.

Browsing history commands from the CLI, aka ^p and ^n, is using (hist>pos)
to keep the current location.

History commands are stored as counted strings, i.e. 1 byte length
followed by #TIBLINE chars.

btw, #tib is not trusted to be in the range 0 to 80.

TODO: Is counted-string of 81 char align-friendly?







                                                                     vandys
history
  Show history commands, each line starting with a running index.
  The command string show is limited to #HISTSH chars in order
  to allow show of a 32-bit index and avoid display line wraparound.
  The history buffer is presented oldest first. As fewer commands
  may be present, non-existing indices are quietly ignored.

TODO: 32-bit counter wraparound - verify no history loss.
      (As 32-bit cell becomes negative after 2G operations
      and rollover after 4G, the issue seems, ahem, not too urgent...)














                                                                     shacham
(>histp) makes sure the user stays within the history buffer boundaries,
i.e. -1 to -#HIST, where -#HIST is the oldest command in the history
buffer.  The corner case where the buffer is yet to be full is taken
into consideration.  In all cases, the user is guided not to walk
past the oldest command in history buffer. Reaching index 0 is
equivalent to clearing the line.

(clrbl) aims to remove user-inserted trailing blanks.

(<hist) uses string-end as limit for do and sring-start as init value,
which is available via i and keeps incrementing, enabling fetching
the present char for 'tap'.













: kTAP Process a non-printable key stroke, CR, backspace et al
  Process keys outside the printable range (bl to ~)
  Supported control keys processed are: CR, command history,
   and line editing.
  Unsupported keys are echoed as bl.
  CR is preceeded by ^e as the line is cut at cur.
  Keys >127 are not reaching here.

: blank Fill in a range with the blank character
: accept Accept characters to input buffer. Return actual count.
 Note that unused trailing part of buffer will be blanked




: expect Accept input stream and store count in SPAN




























































: query Accept input stream to terminal input buffer


Address of a null string with zero count

: abort Reset data stack and jump to QUIT


















: $interpret Interpret word. If failed, try to convert it to an integer




: [ Start the text interpreter

: compiling? Tell if in compilation mode
: .ok Display 'ok' only while interpreting

: ?stack Abort if the data stack underflows


































































       Reset return stack, console state

  Clean up operand stack and TIB
  Begin interpretation
   Get and evaluate
  Until error...
  Save input device (this needs to be deleted... obsolete)
  Display error message


  Obsolete: in file I/O mode, display special escape char














: ' Search context vocabularies for next word in input stream
: , Compile an integer into the code dictionary
: [compile] Compile the next immediate word into code dictionary
: (compile) Run-time for \"compile\"
: (genhook) Next word is about to be compiled, provide hook

: compile Compile the next address in colon list to code dictionary

































































































































































































Flag whether to watch tokens coming into the compiler

: $compile Compile next word to code dictionary as a token or literal





















: overt Link a new word into the current vocabulary
 If \"last\" is 0, the current compilation is a :noname, so no action needed
: (;) Flag end of high-level def

: ?csp Abort if stack pointer differs from that saved in CSP.


: ; Terminate a colon definition, hook for OO to catch stray ;
   Let debugger generate a closing hook; turn off generation suspender
   Compile actual exit code, then marker for end of code body
   Switch mode back to interpreting, thread defined word into dictionary
   Hook for local variables, then verify operand stack






































: (:) Create new colon definition using passed string
: : Start a new colon definition using next word as its name

: immediate Make the last compiled word an immediate word

: compile-only Make the last compiled word a compile-only word



: user Compile a new user variable














: (listent) Create a new dictionary entry which executes high-level code
: (create) Build a create-type entry with passed string
: create Build new entry whose runtime action is to push its address

: variable Create new entry with one cell of body, initialized to 0

: (constant) Create constant-type entry with passed name and value
: constant Build new constant

: _type Display string, omitting non-printing chars



















































































































: (see) Decompile words starting at the given address

         Stop decompiling at end of definition
         Try converting to a name
      If converted, .id it, otherwise just dump its address

: see Parse word from input, decompile at that address

: words Display names in 1st dictionary in search order















                                                                     vandys
















('endDef) Hook to know when definition target is set


















































































                                                                     vandys
Size in bytes of memory starting at 1 meg
: hi Display the sign-on message of ForthOS


: init-bootinfo Parse Multiboot info if available, save memory config.
 If it isn't available, default to assuming 4 megs of upper memory.
 (Note on warm restart we just need to trust the saved value.)
: cold The hilevel cold start sequence
 Parse Multiboot input, set up memory config values
  Initialize the user area
  Init the data stack
  Execute boot words
  Init TTY I/O and print the startup message
  Start interpretation... should not return



































"